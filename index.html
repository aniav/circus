<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Getting recommendations out of nothing</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>
        <script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/javascript">
Reveal.addEventListener( 'slidechanged', function( event ) {
    MathJax.Hub.Rerender();
} );
</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
    <section>
        <section>
            <h1>
    <br>
</h1>
<h1>getting recommendations</h1>
<h1>out of nothing</h1>
<p style="text-align: right;">
<br>
            </p>
<aside class="notes">Hi, my name is Ania Warzecha, and I will talk about getting recommendations out of mothing.</aside>
        </section>
        <section>
            <h2>about me</h2>
<div>
<ul>
<li>muffin provider @<a href="http://10clouds.com">10Clouds</a>
</li>
<li>recommender system for<br>
            <a href="http://motointegrator.pl">motointegrator.pl</a>
        </li>
<li>master thesis on conversion rates<br>in e-commerce websites<br>
        <br>
        <br>
        <br>
        <br>
</li>
</ul>&nbsp;</div>
<div>
<img src="img/65170faa659e11e2ab9622000a9f1423_7.jpg" style="height: 167.31950855255127px;">
        <img src="img/59c123ccd11311e1890222000a1cfddf_7.jpg" style="height: 165.31950855255127px;">
        <img src="img/picplz_20110815_00003688861_00001.jpg" style="height: 168.31950855255127px;">
        <br>
</div>
<aside class="notes">Just a few words about me. I work at 10Clouds, we make great apps, and I am known for providing muffins. I'm also a python programmer, recently working with coffeescript and a team leader,
    but it's more common for the guys to ask me for muffins, so I guess this is my main role.
</aside>
    </section>
    <section>
        <h2>WHAT TO EXPECT?</h2>
<p>
</p>
<ul>
<li>recommendations - required theory</li>
<li>collecting user input</li>
<li>processing user preferences</li>
<li>using recommendations</li>
</ul>
<aside class="notes">What can you expect? Well, at the time I was thinking about the presentation topic I had the idea that a case study will be the best about a recommendation system in terms of what can you get from this presentation, but because you probably have the basic
    idea baout how such a system is designed in general I decided to change the idea a bit and talk about the parts that require the most research. My talk will cover the very basics of recommendations theory. I will give an overview of the elements needed to collect user input and to process it to create recommendations. You will also hear about how
    the recommendations can be used. I will end up with telling you about testying the recommendations. 
</aside>
    </section>
</section>
<section>
    <section>
        <h2>
    <br>
</h2>
<div>
    <br>
</div>
<div>
    <br>
</div>
<h1>
    </h1>
<h1>THEORY</h1>

<aside class="notes">Let's start with some theory, shall we? It's the part that we usually hate at school, but we need it anyways.
</aside>
    </section>
    <section>
        <h2>What are recommendations?</h2>
<div>
<i>
<br>
    </i>
</div>
<div>
    <i>Estimating ratings or preferences for items&nbsp;</i>
</div>
<div>
    <i>that have not been seen by the user.</i>
</div>
<div>
<br>
</div>
<br>
    <div>
\begin{equation}
∀c\in C,\; s^{'}_{c} = \underset{s \in S}{arg\: max\: u(c, s)}
\end{equation}
</div>
<aside class="notes">Recommendations problem can be reduced to a problem of estimating ratings or preferences for items that have not been seen by the user.
    Once the estimations can be calculated we can take items with the highest ratings and define recommendations basing on the highest ratings.
    More formally, the recommendation problem can be formulated as follows. Let C be the 3
set of all users and let S be the set of all possible items that can be recommended, such as books, 
movies, or restaurants. The space S of possible items can be very large, ranging in hundreds of 
thousands or even millions of items in some applications, such as recommending books or CDs. 
Similarly, the user space can also be very large – millions in some cases. Let u be a utility 
function that measures usefulness of item s to user c, i.e., uC x S → R : × → , where R is a totally 
ordered set (e.g., non-negative integers or real numbers within a certain range). Then for each 
user c ∈ C, we want to choose such item s' ∈ S that maximizes the user’s utility
</aside>
</section>
<section>
    <h1>
        <br>
    </h1>
<h1>
    <br>
    </h1>
<h1>EXAMPLES</h1>
</section>
<section>
    <h2>AMAZON</h2>
<img src="img/Amazon.co.uk__Low_Prices_in_Electronics__Books__Sports_Equipment___more.png" style="height: 397.31950855255127px;">
    <aside class="notes">Recommendations can be found all over internet starting from Amazon. Their book reocmmendations tends to be really accurate,
    they use the rating system, user actions history and the information about the books to produce valuable recommendations.
    While examining the topic more carefully you could notice that the system would sometimes recommend a book you have already bought.
</aside>
</section>
<section>
    <h2>
    NETFLIX</h2>
<img src="img/netflix-recommendations.jpg" style="width: 751.3195085525513px;">
    <aside class="notes">The next recommendation system that has to be mentioned is used in netflix. Some might rememeber their competition held a few 
    years ago that was meant to increase recommendations accuracy for movie suggestions. They use many similarity algorithms combined for 
    producing recommendations.
</aside>
</section>
<section>
    <h2>GOODREADS</h2>
<img src="img/Goodreads___Recommended_for_You.png" style="height: 527.3195085525513px;">
    <br>
    <aside class="notes">Goodreads is another example of a recommendation system that is produced from user ratings. The suggestions are divided
    by book shelves: read, curently-reading and to-read, to produce different suggestion types.
</aside>
</section>
<section>
    <h2>SPOTIFY</h2>
<div>
    <img src="img/Screenshot_from_2013-05-12_14_43_47.png" style="">
    <br>
</div>
<aside class="notes">There is also spotify and here we come to a place where the user can only define his likes by listening to a song more frequently than
    other songs or by starring a specific song. They then are able to create a starred songs radio station. It is worth mentioning that this radio station
    can also do further learning from user actions because they are given the option of liking/disliking songs. 
</aside>
</section>
<section>
    <h2>facebook</h2>
    <img src="img/Screenshot_from_2013-05-12_17_30_37.png" style="height: 522.3195085525513px;">
    <aside class="notes">Facebook's recommendation system takes our likes and combines it with do our friends with similar tastes like.
        For recommending sites they also have only our likes. These are not fully our preferences because we can't define our dislikes.
    </aside>
</section>
<section>
    <h2>RECOMMENDER SYSTEMS</h2>
<div>
<br>
</div>
<div>
<div>
    <ul>
<li>
            <span style="text-align: center;">
<span style="font-size: 35.84229278564453px; font-style: normal; font-variant: normal;">Collaborative recommendations</span>
<br>
</span>
        </li>
        <li>
<span style="font-size: 35.84229278564453px; font-style: normal; font-variant: normal; text-align: center;">Content-based recommendations</span>
<br>
</li>
<li>
    <span style="text-align: center;">
        <span>Hybrid methods</span>
<br>
</span>
</li>
</ul>
</div>
</div>
<div>
    <h3>
        <ul>
</ul>
</h3>
</div>
<aside class="notes">All the shown recommendations are created by recommendaer systems. These systems can be divided into three main groups:
    Content-based recommendations where the user is recommended items similar to the ones the he has referred in the past
    Collaborative recommendations in which the user is recommended items that people with similar tastes and preferences liked in the past.
    And Hybrid approaches, that are the methods combining collaborative and content-based methods.
</aside>
</section>
    <section>
        <h2>COLLABORATIVE RECOMMENDATIONS</h2>
        <div>
            <i>
            <br>
        </i>
    </div>
    <div>
        <i>The user is recommended items</i>
    </div>
    <div>
        <i>that people with similar tastes</i>
    </div>
    <div>
        <i>and preferences liked in the past.</i>
        <br>
    </div>
</section>
<section>
    <h2>COLLABORATIVE RECOMMENDATIONS</h2>
<div>
<ul style="list-style: none;">
<li>
<font color="#fffcfc">
    <br>
</font>
</li>
<li>
<font color="#fffcfc">+ &nbsp;simpler to implement
</font>
</li>
<li>
<font color="#fffcfc">+ &nbsp;good for small in-memory datasets<br>&nbsp; &nbsp; &nbsp;that change frequently
</font>
</li>
<li>
<font color="#fffcfc">- &nbsp; slow for a large dataset
</font>
</li>
<li>
<font color="#fffcfc">- &nbsp; inaccurate for sparse data</font>
</li>
<li>
    <font color="#fffcfc">- &nbsp; inaccurate for new users</font>
</li>
<li>
    <font color="#fffcfc">- &nbsp; inaccurate for new items</font>
</li>
</ul>
</div>
<div>
<br>
</div>
<aside class="notes">
    Collaborative recommendations or user-based recommendations are best for small datasets that won't grow in time they tend to be slow and inacurate for
    large datasets. Usually calculating recommendations wil be easier to implement - because we only have to find users with similar tastes or similar user profile
    and afterwards operate on the dataset containing only these similar users to produce recommendations. These recommendations tend to be inaccurate for new items,
    because these won't be recommended to anyone untill users won't rate them. New users won't have appropriate recommendations until the system won't
    learn about their preferences.
</aside>
</section>
<section>
    <h2>CONTENT-BASED RECOMMENDATIONS</h2>
    <div>
        <i>
        <br>
    </i>
</div>
<div>
    <i>The user is recommended items</i>
</div>
<div>
    <i>similar to the ones</i>
</div>
<div>
    <i>the he has referred in the past.</i>
    <br>
</div>
</section>
<section>
    <h2>CONTENT-BASED RECOMMENDATIONS</h2>
<div>
<ul style="list-style: none;">
<li>
<font color="#fffcfc">+ &nbsp;fast for any dataset</font>
</li>
<li>
<font color="#fffcfc">+ &nbsp;accurate for any dataset</font>
</li>
<li>
<font color="#fffcfc">- &nbsp; additional overhead for item<br>&nbsp; &nbsp; &nbsp;similarity storage</font>
</li>
<li>
<font color="#fffcfc">- &nbsp; more complicated to implement and test</font>
</li>
<li>- &nbsp; limited by te features explicitly associated<br>&nbsp; &nbsp; &nbsp;with the items</li>
<li>- &nbsp; over-specialization</li>
<li>- &nbsp; inaccurate for new users</li>
</ul>
</div>
<aside class="notes">
    Content based recommendations need additional similairty storage which is also good and bad, you have to set it up and maintain it but
    it will hold precalculated similarities which will be used for producing recommendations. This makes the content-based recommendations
    a lot faster for any dataset. As with the user-based recommendations the new users will have to provide some information to have proper 
    recommendations served. Recommendations systems tend to be over-specialized or in other words limited to a specific set of itesm,
    for example a user that has not read anything from science-fiction or hasn't provided any information about might not ever have
    it recommended. Item-based recommendations are also limited to the features explicitly associated with the items so the items should be in a 
    ready-to-parse form or their attributes should be defined manually.
</aside>
</section>
<section>
    <h2>HYBRID METHODS</h2>
<div>
    <ul>
<li>combining separate recommenders</li>
        <li>adding content-based characteristics<br>to user-based models</li>
        <li>adding collaborative characteristics<br>to content-based models</li>
        <li>developing a single unifying<br>recommendation model</li>
    </ul>
</div>
<aside class="notes">Hybrid methods can be divided into four types. Combining separate recommenders is a way of building both user-based and item-based 
    recommendations ystems. It doesn't have to mean that we will have to have much more work than compring to the cntent-based method, but we can combine bith 
    systems to give more confidend or more consistent results, for example by linear combining of ratings or a voting scheme.
    Adding content-based characteristics to user-based models and the other way round are methods that use additional attributes to boost recommendation 
    effectiveness, for example in the first case we would not only recommend items that rate highly for the pas users ratings but we would also recommend items
    that are appropriate for the users profile.
    Developing a single unifying recommendation model means to use both user-based and content-based preferences for estimations using for example probabilistic
    or mixed-regression methods. Might be a lot of fun developing and testing if you have a lot of time :)
</aside>
</section>
</section>
<section>
    <section>
        <div>
            <br>
        </div>
        <h1>
            <br>
        </h1>
        <h1>USE CASE</h1>
    </section>
    <section>
        <h2>
            <a href="http://motointegrator.pl">motointegrator.pl</a>
        </h2>
        <img src="img/Akcesoria_i_cz__ci_samochodowe___sklep_Grupy_Inter_Cars___Motointegrator.pl.png" style="">
    </section>
    <section>
        <h2>
            <br>
        </h2>
        <div>
            <img src="img/MotoIntegrator.png" style="">
            <br>
        </div>
    </section>
    <section>
        <h2>
            <img src="img/Cz__ci_zamienne___sklep_internetowy_Motointegrator.pl.png" style="height: 599.3195085525513px;">
            <br>
        </h2>
    </section>
    <section>
        <h2>
    STARTING POINT
<br>
<br>
</h2>
<div>
<span style="text-align: left;">big set of items (&gt;100k)</span>
<br>
<span style="text-align: left;">no review system</span>
    </div>
    <div>PostgreSQL, Redis, Solr, Django<br style="font-family: inherit; font-style: inherit; font-variant: inherit; text-align: left;">
<div>
    <br>
</div>
<div>↓</div>
<div>
    <br>
</div>
<div>content-based &nbsp;recommendations<br>
</div>
<ul>
</ul>
</div>
<aside class="notes">
    As a starting point our website has a big database of items and we don't have any rating system. Our data is sparse. These base conditions require that we 
    use a content-base approach, and because we don't have a recommendations system we will want to tune it with collaborative metrics.
</aside>
</section>
</section>
<section>
    <section>
        <h1>
    <br>
</h1>
<div>
        <br>
        </div>
<h1>COLLECT<br>USER&nbsp;DATA</h1>
<aside class="notes">Let's collect some user data</aside>
    </section>
    <section>
        <h1>
    <br>
    USER RATINGS<br>
    =<br>
    user actions

</h1>
<aside class="notes">First of all we need to know what our ratings will be. We have to use all user actions that are available.
    So browsing, searching, adding to cart, adding to favorites, liking/disliking.
</aside>
    </section>
    <section>
        <h2>SCORE USER ACTIONS</h2>
<div>
    <h3 style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BASIC</h3>
</div>
<div>
    <ul style="list-style: none; display: block; margin-left: 135px;">
<li>0 - didn't buy</li>
        <li>1 - browsed</li>
        <li>2 - bought</li>
    </ul>
</div>
<div>
    <h3 style="text-align: left;">
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXTENDED</h3>
</div>
<div>
<ul>
<li>
<span>higher score for&nbsp;</span>
        <span>items&nbsp;reached via search</span>
    </li>
    <li>
        <span style="text-align: left;">add score for wish list</span>
</li>
<li>
    <span style="text-align: left;">distinguish added to cart&nbsp;and&nbsp;bought</span>
</li>
</ul>
</div>
























</section>
        <section>
            <h2>STORE USER ACTIONS</h2>
<div>
    <br>
</div>
<div>
<br>
</div>
<img src="img/redis-300dpi.png" width="200px" style="width: 298.31950855255127px;">&nbsp;<div>
<img src="img/1605635.png" width="200px" style="width: 394.31950855255127px;">
            <img src="img/couch.png" width="150px" style="width: 219.31950855255127px;">
            <aside class="notes">
We want to store the actions that the user has taken. The storing process should be fast and it doesn't really require any indexing and so on so we would 
want to use
</aside>
</div>
</section>
            <section>
<h2>USER ACTIONS STORE</h2>
<div>
<br>
</div>
<div>Concept</div>
<pre><code>{'popeye': (838091372, 1), (169595046, 2), (222083613, 1)}
{'amelie': (204548150, 2), (558149454, 1),...}</code>            </pre>

<div>
</div>Redis<br>
<pre><code># Add a new item_id to the user_key list
redis.lpush(user_key, item_id)</code></pre>    <pre><code># Cut out the oldest elements
redis.ltrim(user_key, 0, max_elements)
</code></pre>
<pre><code># Add the user_key to registry
redis.sadd(registry_key, user_key)</code>        </pre>


















</section>
        <section>
            <h2>Don't lose your data!</h2>
<div>
<span style="text-align: left;">
    <br>
        </span>
</div>
<div>

<span style="text-align: left;">Track users that aren't logged in.</span>

</div>
<div>

    <span style="text-align: left;">
        <br>
    </span>
</div>
<div>

    <span style="text-align: left;">↓</span>

</div>
<div>

    <span style="text-align: left;">
        <br>
</span>

</div>
<div>

<span style="text-align: left;">Merge session keys<br>
</span>
<span style="text-align: left;">when the user logs in.</span>

<br>
</div>

</section>
<section>
    <h2>
        <br>
    </h2>
<h1>
    <br>
    </h1>
<h1>COLD START</h1>
</section>
</section>
<section>
    <section>
        <h1>
            <br>
        </h1>
<div>
        <br>
        </div>
<h1>CALCULATE<br>SIMILARITIES</h1>
    </section>
    <section>
        <h2>
    <br>
</h2>
<div>
<br>
</div>
<h1>
<br>
</h1>
<h1>FIND SIMILAR USERS</h1>
<div>
</div>

<aside class="notes">After collecting the data we have a set of users with they preferences, and we can take a user and compare it with all the other users in the set to produce similarities.</aside>
    </section>
    <section>
        <h2>SIMILARITY SCORE</h2>
<div>
        <ul>
<li>
        <span style="text-align: center;">Euclidean Distance</span>
    </li>
<li>
    <span style="text-align: center;">Pearson Correlation</span>
</li>
<li>
<span style="text-align: center;">Cosine Similarity</span>
</li>
</ul>
</div>
<div>
    <br>
</div>
<div>
    <br>
</div>
<div>&nbsp;</div>
<aside class="notes">Similarity between two users is based on
actions taken by both of them on the same items.</aside>
</section>
<section>
    <h2>
<img src="img/EUCLIDEAN_DISTANCE_SCORE__1_.png" style="height: 599.3195085525513px;">
    <br>
</h2>
</section>
<section>
<h2>euclidean distance score</h2>
<pre><code>def sim_distance(user_data, p1, p2):
    """Return the distance-based similarity score for p1 and p2
    The returned values should be between -1 and 1"""

    if (p1 not in user_data or p2 not in user_data or
            (user_data[p1] == 0.0 and user_data[p2] == 0.0)):
        return 0

    si = {}
    for item in user_data[p1]:
        if item in user_data[p2]:
            si[item] = 1
    # Find the number of elements
    n = len(si)
    # If they have no rating in common, return 0
    if n == 0:
        return 0

    # Add up the squares of all the differences
    squares_sum = sum([pow(user_data[p1][i]-user_data[p2][i], 2)
                          for i in si])
    return 1 / (1 + sqrt(squares_sum))</code></pre>
</section>
<section>
    <h2>
<img src="img/PEARSON_CORRELATION_SCORE1.png" style="font-size: 75.96px; height: 587.3195085525513px;">
    <br>
</h2>
</section>
<section>
<h2>RANK THE USERS</h2>
<div>Create a rank for each user in the dataset and get the</div>
<div>top ones</div>
<div>
    <pre><code>def get_top_matches(user, ratings, max_items):
    """Get the most similar matches for specified user."""
    scores = [(sim(ratings, user, x), x)
              for x in ratings if user != x]
    scores = sorted(scores, reverse=True)
    return scores[:max_items]<br></code></pre>
</div>
</section>
<section>
    <h2>
        <br>
    </h2>
<div>
    <br>
</div>
<div>
<br>
</div>
<div>
<br>
</div>
<h1>RECOMMENDATIONS<br>ALWAYS SUCK!</h1>
</section>
<section>
<h2>CREATE SIMILARITIES dataset</h2>
<div>
    <pre><code style="max-height: 550px;">def calculate_similar_items(user_keys):
    """Calculate similar items and set them in their keys in redis"""
    objs = {}
    for user_key in user_keys:
        # Get all the user ratings
        scores = redis.lrange(user_key, start=0, end=-1)
        for obj in scores:
            objs.setdefault(obj, {})
            objs[obj][user_key] = 1  # Or any specific weight

    for obj in objs:
        # Find the most similar items
        scores = get_top_matches(obj, objs, 5)
        if not scores:
            continue
        # Get the object key to be set in redis
        obj_key = get_key('similar_prefix', obj)

        # Set the scores in redis, and add the key to registry
        scores_mapping = map(dict(x[1], x[0]) for x in scores)
        redis.zadd(obj_key, **scores_mapping)  # sorted set
        redis.sadd('similar_registry', obj_key)  # set</code></pre>
</div>

</section>
</section>
<section>
    <section>
        <h2>
            <br>
        </h2>
<h1>
        <br>
        </h1>
<h1>Recommend!</h1>
    </section>
    <section>
        <h2>USE CASES</h2>
<div>
<ul>
<li>recommend items to users</li>
<li>recommend items similar to<br>a specific item</li>
<li>find users that would likely<br>be interested in certain items</li>
</ul>
</div>
</section>
        <section>
<h2>item recommendations</h2>
<div>
    <pre><code style="max-height: 550px;">def get_items_recommendations(items, max_items=10):
    """ Get recommendations for the provided items.
    The returned value will be a list of tuples
    [('AEC234', 0.89), ('123ASW': 0.86'),...] """

    # Gather the keys for items, which hold the similrities
    item_keys = [get_redis_key('similar_prefix', x) for x in items]

    # Get the items recommendations sorted by score descending.
    # We need a random key for redis
    scores_key = get_redis_key('score', os.urandom(8))

    # Get the common items, their scores will be added
    # and the set will be sorted in redis
    redis.zunionstore(scores_key, keys=item_keys)
    rankings = redis.zrevrange(scores_key, start=0, num=-1,
                               withscores=True)

    # Filter out current items
    rankings = [x for x in rankings if x not in items]

    # And return the rankings
    return rankings[:max_items]</code>        </pre>
</div>











</section>
        <section>
<h2>USER RECOMMENDATIONS</h2>
<div>
<pre><code style="max-height: 550px;">get_user_recommendations(user_ratings, max_items=10):
    """Get the recommendations for user using his history """

    # Get weighted scores, each key will be added to a new sorted set
    # Each key from the items similarities set will be multiplied
    # by the rating from the user_ratings set
    weighted_score_key = get_redis_key(user_key, 'weighted_score',
                                       <span style="font-family: monospace; font-size: 19.201229095458984px; font-style: normal; font-variant: normal;">os.urandom(8)</span>)
    redis.zunionstore(weighted_score_key, keys=user_ratings)
    weighted_scores = redis.zrevrange(weighted_score_key, start=0,
                                      num=-1, withscores=True)

    score_key = get_redis_key(user_key, 'score', <span style="font-family: monospace; font-size: 19.201229095458984px; font-style: normal; font-variant: normal;">os.urandom(8)</span>)
    redis.zunionstore(score_key, keys=user_ratings.keys())
    scores = redis.zrevrange(score_key, start=0, num=-1,
                             withscores=True)
    scores = map(dict(key, value) for key, value in scores)

    rankings = []
    for item, score in weighted_scores:
        rankings.append((item, score/scores[item]))
    rankings = sorted(rankings, key=lambda x: x[1], reverse=True)
    return rankings[:max_items]</code>        </pre>
</div>





</section>
        <section>
            <h2>SQUEEZE THE ITEMS</h2>
<div>
            <ul>
<li>categories</li>
<li>item - connections</li>
<li>item - alternatives</li>
<li>keywords</li>
</ul>
        </div>
    </section>
</section>
<section>
    <h2>TEST</h2>
<div>
    <ul>
<li>stress tests</li>
<li>effectiveness tests<br>(Mean Squared Error, Root Mean Squared Error)</li>
    <li>conversion rate tests</li>
</ul>
</div>
</section>
<section>
    <h2>Consclusion</h2>
    <div>
        <ul>
            <li>content-based recommendations<br>for big item-sets</li>
            <li>Redis for fast storing<br>and &nbsp;painless calculations<br>
            </li>
            <li></li>
        </ul>
    </div>
</section>
<section>
    <h2>References</h2>
<div>
    <ul>
<li>
    <a href="http://shop.oreilly.com/product/9780596529321.do">Programming Collective Intelligence</a>
</li>
<li>
<a href="http://www.cs.umd.edu/~samir/498/Amazon-Recommendations.pdf">Amazon.com&nbsp;<span>Recommendations<br>
</span>
<span>Item-to-Item Collaborative Filtering</span>
</a>
</li>
<li>
<a href="http://books.google.pl/books?id=2hFG21Cp2qcC&amp;printsec=frontcover&amp;source=gbs_ge_summary_r&amp;cad=0#v=onepage&amp;q&amp;f=false">Recommender Systems Handbook</a>
</li>
<li>
<a href="http://homepages.dcc.ufmg.br/~nivio/cursos/ri13/sources/recommender-systems-survey-2005.pdf">Towards the Next Generation of Recommender<br>Systems:&nbsp;<span>A Survey of the State-of-the-Art<br>and Possible Extensions</span>
</a>
</li>
</ul>
</div>
</section>
<section>
    <h2>Questions?</h2>
<div>
    <br>
</div>
<div>
    <br>
</div>
<div>
    <br>
</div>
<div>
    <br>
</div>
    <div>
        <br>
    </div>
    <div>
        <br>
    </div>
    <div>
        <br>
    </div>
    <div>
        <br>
        </div>
<div>
    <br>
</div>
<div>
    <br>
</div>
<div style="text-align: right; padding-right: 50px;">
    <a href="http://aniav.github.io/circus/">aniav.github.io/circus</a><br/><br/>
    <a href="https://twitter.com/aniawarzecha">@aniawarzecha</a>
        <br>
anna.warzecha@gmail.com
</div>





</section>
    </div>










		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
